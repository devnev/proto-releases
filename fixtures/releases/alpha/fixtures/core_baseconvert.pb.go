// Code generated by protoc-gen-go-baseconvert. DO NOT EDIT.

package fixtures

import (
	context "context"
	fixtures "github.com/devnev/proto-releases/fixtures"
	grpc "google.golang.org/grpc"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

func (m *EmptyMessageNotAnnotated) ToBase() *fixtures.EmptyMessageNotAnnotated {
	msg := &fixtures.EmptyMessageNotAnnotated{}
	return msg
}
func (m *EmptyMessageNotAnnotated) FromBase(b *fixtures.EmptyMessageNotAnnotated) *EmptyMessageNotAnnotated {
	if m != nil {
		m.Reset()
	} else {
		m = new(EmptyMessageNotAnnotated)
	}
	return m
}
func (m *EmptyMessageReleased) ToBase() *fixtures.EmptyMessageReleased {
	msg := &fixtures.EmptyMessageReleased{}
	return msg
}
func (m *EmptyMessageReleased) FromBase(b *fixtures.EmptyMessageReleased) *EmptyMessageReleased {
	if m != nil {
		m.Reset()
	} else {
		m = new(EmptyMessageReleased)
	}
	return m
}
func (m *EmptyMessagePreviewed) ToBase() *fixtures.EmptyMessagePreviewed {
	msg := &fixtures.EmptyMessagePreviewed{}
	return msg
}
func (m *EmptyMessagePreviewed) FromBase(b *fixtures.EmptyMessagePreviewed) *EmptyMessagePreviewed {
	if m != nil {
		m.Reset()
	} else {
		m = new(EmptyMessagePreviewed)
	}
	return m
}
func (m *EmptyMessagePreviewedThenReleased) ToBase() *fixtures.EmptyMessagePreviewedThenReleased {
	msg := &fixtures.EmptyMessagePreviewedThenReleased{}
	return msg
}
func (m *EmptyMessagePreviewedThenReleased) FromBase(b *fixtures.EmptyMessagePreviewedThenReleased) *EmptyMessagePreviewedThenReleased {
	if m != nil {
		m.Reset()
	} else {
		m = new(EmptyMessagePreviewedThenReleased)
	}
	return m
}
func (m *EmptyMessagePreviewedThenRemoved) ToBase() *fixtures.EmptyMessagePreviewedThenRemoved {
	msg := &fixtures.EmptyMessagePreviewedThenRemoved{}
	return msg
}
func (m *EmptyMessagePreviewedThenRemoved) FromBase(b *fixtures.EmptyMessagePreviewedThenRemoved) *EmptyMessagePreviewedThenRemoved {
	if m != nil {
		m.Reset()
	} else {
		m = new(EmptyMessagePreviewedThenRemoved)
	}
	return m
}
func (m *EmptyMessageReleasedThenRemoved) ToBase() *fixtures.EmptyMessageReleasedThenRemoved {
	msg := &fixtures.EmptyMessageReleasedThenRemoved{}
	return msg
}
func (m *EmptyMessageReleasedThenRemoved) FromBase(b *fixtures.EmptyMessageReleasedThenRemoved) *EmptyMessageReleasedThenRemoved {
	if m != nil {
		m.Reset()
	} else {
		m = new(EmptyMessageReleasedThenRemoved)
	}
	return m
}
func (m *MessageWithNoAnnotations) ToBase() *fixtures.MessageWithNoAnnotations {
	msg := &fixtures.MessageWithNoAnnotations{
		NotAnnotated: m.GetNotAnnotated(),
	}
	return msg
}
func (m *MessageWithNoAnnotations) FromBase(b *fixtures.MessageWithNoAnnotations) *MessageWithNoAnnotations {
	if m != nil {
		m.Reset()
	} else {
		m = new(MessageWithNoAnnotations)
	}
	m.NotAnnotated = b.GetNotAnnotated()
	return m
}
func (m *MessageWithReleasedField) ToBase() *fixtures.MessageWithReleasedField {
	msg := &fixtures.MessageWithReleasedField{
		Released: m.GetReleased(),
	}
	return msg
}
func (m *MessageWithReleasedField) FromBase(b *fixtures.MessageWithReleasedField) *MessageWithReleasedField {
	if m != nil {
		m.Reset()
	} else {
		m = new(MessageWithReleasedField)
	}
	m.Released = b.GetReleased()
	return m
}
func (m *MessageWithPreviewField) ToBase() *fixtures.MessageWithPreviewField {
	msg := &fixtures.MessageWithPreviewField{
		Released: m.GetReleased(),
	}
	return msg
}
func (m *MessageWithPreviewField) FromBase(b *fixtures.MessageWithPreviewField) *MessageWithPreviewField {
	if m != nil {
		m.Reset()
	} else {
		m = new(MessageWithPreviewField)
	}
	m.Released = b.GetReleased()
	return m
}
func (m *MessageWithUnannotatedOneof) ToBase() *fixtures.MessageWithUnannotatedOneof {
	msg := &fixtures.MessageWithUnannotatedOneof{}
	switch o := m.GetNotAnnotatedOneof().(type) {
	case *MessageWithUnannotatedOneof_OneofItemNotAnnotated:
		msg.NotAnnotatedOneof = o.ToBase()
	}
	return msg
}
func (m *MessageWithUnannotatedOneof) FromBase(b *fixtures.MessageWithUnannotatedOneof) *MessageWithUnannotatedOneof {
	if m != nil {
		m.Reset()
	} else {
		m = new(MessageWithUnannotatedOneof)
	}
	switch o := b.GetNotAnnotatedOneof().(type) {
	case *fixtures.MessageWithUnannotatedOneof_OneofItemNotAnnotated:
		m.NotAnnotatedOneof = (*MessageWithUnannotatedOneof_OneofItemNotAnnotated)(nil).FromBase(o)
	}
	return m
}
func (m *MessageWithUnannotatedOneof_OneofItemNotAnnotated) ToBase() *fixtures.MessageWithUnannotatedOneof_OneofItemNotAnnotated {
	return (*fixtures.MessageWithUnannotatedOneof_OneofItemNotAnnotated)(m)
}
func (m *MessageWithUnannotatedOneof_OneofItemNotAnnotated) FromBase(b *fixtures.MessageWithUnannotatedOneof_OneofItemNotAnnotated) *MessageWithUnannotatedOneof_OneofItemNotAnnotated {
	return (*MessageWithUnannotatedOneof_OneofItemNotAnnotated)(b)
}
func (m *MessageWithReleasedOneofItem) ToBase() *fixtures.MessageWithReleasedOneofItem {
	msg := &fixtures.MessageWithReleasedOneofItem{}
	switch o := m.GetOneofWithItem().(type) {
	case *MessageWithReleasedOneofItem_OneofItemNotAnnotated:
		msg.OneofWithItem = o.ToBase()
	case *MessageWithReleasedOneofItem_OneofItemReleased:
		msg.OneofWithItem = o.ToBase()
	}
	return msg
}
func (m *MessageWithReleasedOneofItem) FromBase(b *fixtures.MessageWithReleasedOneofItem) *MessageWithReleasedOneofItem {
	if m != nil {
		m.Reset()
	} else {
		m = new(MessageWithReleasedOneofItem)
	}
	switch o := b.GetOneofWithItem().(type) {
	case *fixtures.MessageWithReleasedOneofItem_OneofItemNotAnnotated:
		m.OneofWithItem = (*MessageWithReleasedOneofItem_OneofItemNotAnnotated)(nil).FromBase(o)
	case *fixtures.MessageWithReleasedOneofItem_OneofItemReleased:
		m.OneofWithItem = (*MessageWithReleasedOneofItem_OneofItemReleased)(nil).FromBase(o)
	}
	return m
}
func (m *MessageWithReleasedOneofItem_OneofItemNotAnnotated) ToBase() *fixtures.MessageWithReleasedOneofItem_OneofItemNotAnnotated {
	return (*fixtures.MessageWithReleasedOneofItem_OneofItemNotAnnotated)(m)
}
func (m *MessageWithReleasedOneofItem_OneofItemNotAnnotated) FromBase(b *fixtures.MessageWithReleasedOneofItem_OneofItemNotAnnotated) *MessageWithReleasedOneofItem_OneofItemNotAnnotated {
	return (*MessageWithReleasedOneofItem_OneofItemNotAnnotated)(b)
}
func (m *MessageWithReleasedOneofItem_OneofItemReleased) ToBase() *fixtures.MessageWithReleasedOneofItem_OneofItemReleased {
	return (*fixtures.MessageWithReleasedOneofItem_OneofItemReleased)(m)
}
func (m *MessageWithReleasedOneofItem_OneofItemReleased) FromBase(b *fixtures.MessageWithReleasedOneofItem_OneofItemReleased) *MessageWithReleasedOneofItem_OneofItemReleased {
	return (*MessageWithReleasedOneofItem_OneofItemReleased)(b)
}
func (m *MessageWithOneofWithMessages) ToBase() *fixtures.MessageWithOneofWithMessages {
	msg := &fixtures.MessageWithOneofWithMessages{}
	switch o := m.GetOneofWithMessage().(type) {
	case *MessageWithOneofWithMessages_MessageWithNoAnnotations:
		msg.OneofWithMessage = o.ToBase()
	case *MessageWithOneofWithMessages_MessageWithReleasedField:
		msg.OneofWithMessage = o.ToBase()
	case *MessageWithOneofWithMessages_MessageWithReleaseAnnotation:
		msg.OneofWithMessage = o.ToBase()
	}
	return msg
}
func (m *MessageWithOneofWithMessages) FromBase(b *fixtures.MessageWithOneofWithMessages) *MessageWithOneofWithMessages {
	if m != nil {
		m.Reset()
	} else {
		m = new(MessageWithOneofWithMessages)
	}
	switch o := b.GetOneofWithMessage().(type) {
	case *fixtures.MessageWithOneofWithMessages_MessageWithNoAnnotations:
		m.OneofWithMessage = (*MessageWithOneofWithMessages_MessageWithNoAnnotations)(nil).FromBase(o)
	case *fixtures.MessageWithOneofWithMessages_MessageWithReleasedField:
		m.OneofWithMessage = (*MessageWithOneofWithMessages_MessageWithReleasedField)(nil).FromBase(o)
	case *fixtures.MessageWithOneofWithMessages_MessageWithReleaseAnnotation:
		m.OneofWithMessage = (*MessageWithOneofWithMessages_MessageWithReleaseAnnotation)(nil).FromBase(o)
	}
	return m
}
func (m *MessageWithOneofWithMessages_MessageWithNoAnnotations) ToBase() *fixtures.MessageWithOneofWithMessages_MessageWithNoAnnotations {
	return &fixtures.MessageWithOneofWithMessages_MessageWithNoAnnotations{
		MessageWithNoAnnotations: m.MessageWithNoAnnotations.ToBase(),
	}
}
func (m *MessageWithOneofWithMessages_MessageWithNoAnnotations) FromBase(b *fixtures.MessageWithOneofWithMessages_MessageWithNoAnnotations) *MessageWithOneofWithMessages_MessageWithNoAnnotations {
	return &MessageWithOneofWithMessages_MessageWithNoAnnotations{
		MessageWithNoAnnotations: (*MessageWithNoAnnotations)(nil).FromBase(b.MessageWithNoAnnotations),
	}
}
func (m *MessageWithOneofWithMessages_MessageWithReleasedField) ToBase() *fixtures.MessageWithOneofWithMessages_MessageWithReleasedField {
	return &fixtures.MessageWithOneofWithMessages_MessageWithReleasedField{
		MessageWithReleasedField: m.MessageWithReleasedField.ToBase(),
	}
}
func (m *MessageWithOneofWithMessages_MessageWithReleasedField) FromBase(b *fixtures.MessageWithOneofWithMessages_MessageWithReleasedField) *MessageWithOneofWithMessages_MessageWithReleasedField {
	return &MessageWithOneofWithMessages_MessageWithReleasedField{
		MessageWithReleasedField: (*MessageWithReleasedField)(nil).FromBase(b.MessageWithReleasedField),
	}
}
func (m *MessageWithOneofWithMessages_MessageWithReleaseAnnotation) ToBase() *fixtures.MessageWithOneofWithMessages_MessageWithReleaseAnnotation {
	return &fixtures.MessageWithOneofWithMessages_MessageWithReleaseAnnotation{
		MessageWithReleaseAnnotation: m.MessageWithReleaseAnnotation.ToBase(),
	}
}
func (m *MessageWithOneofWithMessages_MessageWithReleaseAnnotation) FromBase(b *fixtures.MessageWithOneofWithMessages_MessageWithReleaseAnnotation) *MessageWithOneofWithMessages_MessageWithReleaseAnnotation {
	return &MessageWithOneofWithMessages_MessageWithReleaseAnnotation{
		MessageWithReleaseAnnotation: (*MessageWithReleasedField)(nil).FromBase(b.MessageWithReleaseAnnotation),
	}
}
func (m *MessageWithImportedFields) ToBase() *fixtures.MessageWithImportedFields {
	msg := &fixtures.MessageWithImportedFields{
		Empty:          m.GetEmpty().ToBase(),
		WithUnreleased: m.GetWithUnreleased().ToBase(),
		WithReleased:   m.GetWithReleased().ToBase(),
		EmptyReleased:  m.GetEmptyReleased().ToBase(),
	}
	return msg
}
func (m *MessageWithImportedFields) FromBase(b *fixtures.MessageWithImportedFields) *MessageWithImportedFields {
	if m != nil {
		m.Reset()
	} else {
		m = new(MessageWithImportedFields)
	}
	m.Empty = m.Empty.FromBase(b.GetEmpty())
	m.WithUnreleased = m.WithUnreleased.FromBase(b.GetWithUnreleased())
	m.WithReleased = m.WithReleased.FromBase(b.GetWithReleased())
	m.EmptyReleased = m.EmptyReleased.FromBase(b.GetEmptyReleased())
	return m
}
func (m *MessageNotAnnotated) ToBase() *fixtures.MessageNotAnnotated {
	msg := &fixtures.MessageNotAnnotated{
		NotAnnotated:          m.GetNotAnnotated(),
		Released:              m.GetReleased(),
		Previewed:             m.GetPreviewed(),
		PreviewedThenReleased: m.GetPreviewedThenReleased(),
		PreviewedThenRemoved:  m.GetPreviewedThenRemoved(),
		ReleasedThenRemoved:   m.GetReleasedThenRemoved(),
	}
	switch o := m.GetNotAnnotatedOneof().(type) {
	case *MessageNotAnnotated_OneofItemNotAnnotated:
		msg.NotAnnotatedOneof = o.ToBase()
	}
	return msg
}
func (m *MessageNotAnnotated) FromBase(b *fixtures.MessageNotAnnotated) *MessageNotAnnotated {
	if m != nil {
		m.Reset()
	} else {
		m = new(MessageNotAnnotated)
	}
	m.NotAnnotated = b.GetNotAnnotated()
	m.Released = b.GetReleased()
	m.Previewed = b.GetPreviewed()
	m.PreviewedThenReleased = b.GetPreviewedThenReleased()
	m.PreviewedThenRemoved = b.GetPreviewedThenRemoved()
	m.ReleasedThenRemoved = b.GetReleasedThenRemoved()
	switch o := b.GetNotAnnotatedOneof().(type) {
	case *fixtures.MessageNotAnnotated_OneofItemNotAnnotated:
		m.NotAnnotatedOneof = (*MessageNotAnnotated_OneofItemNotAnnotated)(nil).FromBase(o)
	}
	return m
}
func (m *MessageNotAnnotated_OneofItemNotAnnotated) ToBase() *fixtures.MessageNotAnnotated_OneofItemNotAnnotated {
	return (*fixtures.MessageNotAnnotated_OneofItemNotAnnotated)(m)
}
func (m *MessageNotAnnotated_OneofItemNotAnnotated) FromBase(b *fixtures.MessageNotAnnotated_OneofItemNotAnnotated) *MessageNotAnnotated_OneofItemNotAnnotated {
	return (*MessageNotAnnotated_OneofItemNotAnnotated)(b)
}
func (m *MessageWithEnumFields) ToBase() *fixtures.MessageWithEnumFields {
	msg := &fixtures.MessageWithEnumFields{
		NotAnnotated: m.GetNotAnnotated().ToBase(),
		Released:     m.GetReleased().ToBase(),
	}
	return msg
}
func (m *MessageWithEnumFields) FromBase(b *fixtures.MessageWithEnumFields) *MessageWithEnumFields {
	if m != nil {
		m.Reset()
	} else {
		m = new(MessageWithEnumFields)
	}
	m.NotAnnotated = m.NotAnnotated.FromBase(b.GetNotAnnotated())
	m.Released = m.Released.FromBase(b.GetReleased())
	return m
}
func (m *MessageWithOneofsWithEnumFields) ToBase() *fixtures.MessageWithOneofsWithEnumFields {
	msg := &fixtures.MessageWithOneofsWithEnumFields{}
	switch o := m.GetOneofWithEnumField().(type) {
	case *MessageWithOneofsWithEnumFields_NotAnnotated:
		msg.OneofWithEnumField = o.ToBase()
	case *MessageWithOneofsWithEnumFields_Released:
		msg.OneofWithEnumField = o.ToBase()
	}
	return msg
}
func (m *MessageWithOneofsWithEnumFields) FromBase(b *fixtures.MessageWithOneofsWithEnumFields) *MessageWithOneofsWithEnumFields {
	if m != nil {
		m.Reset()
	} else {
		m = new(MessageWithOneofsWithEnumFields)
	}
	switch o := b.GetOneofWithEnumField().(type) {
	case *fixtures.MessageWithOneofsWithEnumFields_NotAnnotated:
		m.OneofWithEnumField = (*MessageWithOneofsWithEnumFields_NotAnnotated)(nil).FromBase(o)
	case *fixtures.MessageWithOneofsWithEnumFields_Released:
		m.OneofWithEnumField = (*MessageWithOneofsWithEnumFields_Released)(nil).FromBase(o)
	}
	return m
}
func (m *MessageWithOneofsWithEnumFields_NotAnnotated) ToBase() *fixtures.MessageWithOneofsWithEnumFields_NotAnnotated {
	return &fixtures.MessageWithOneofsWithEnumFields_NotAnnotated{
		NotAnnotated: m.NotAnnotated.ToBase(),
	}
}
func (m *MessageWithOneofsWithEnumFields_NotAnnotated) FromBase(b *fixtures.MessageWithOneofsWithEnumFields_NotAnnotated) *MessageWithOneofsWithEnumFields_NotAnnotated {
	return &MessageWithOneofsWithEnumFields_NotAnnotated{
		NotAnnotated: (EnumNotAnnotated)(0).FromBase(b.NotAnnotated),
	}
}
func (m *MessageWithOneofsWithEnumFields_Released) ToBase() *fixtures.MessageWithOneofsWithEnumFields_Released {
	return &fixtures.MessageWithOneofsWithEnumFields_Released{
		Released: m.Released.ToBase(),
	}
}
func (m *MessageWithOneofsWithEnumFields_Released) FromBase(b *fixtures.MessageWithOneofsWithEnumFields_Released) *MessageWithOneofsWithEnumFields_Released {
	return &MessageWithOneofsWithEnumFields_Released{
		Released: (EnumNotAnnotated)(0).FromBase(b.Released),
	}
}
func (e EnumNotAnnotated) FromBase(b fixtures.EnumNotAnnotated) EnumNotAnnotated {
	switch b {
	case fixtures.EnumNotAnnotated_zero_value:
		return EnumNotAnnotated_zero_value
	case fixtures.EnumNotAnnotated_not_annotated:
		return EnumNotAnnotated_not_annotated
	case fixtures.EnumNotAnnotated_released:
		return EnumNotAnnotated_released
	case fixtures.EnumNotAnnotated_previewed:
		return EnumNotAnnotated_previewed
	case fixtures.EnumNotAnnotated_previewed_then_released:
		return EnumNotAnnotated_previewed_then_released
	case fixtures.EnumNotAnnotated_previewed_then_removed:
		return EnumNotAnnotated_previewed_then_removed
	case fixtures.EnumNotAnnotated_released_then_removed:
		return EnumNotAnnotated_released_then_removed
	default:
		return EnumNotAnnotated(0)
	}
}
func (e EnumNotAnnotated) ToBase() fixtures.EnumNotAnnotated {
	return fixtures.EnumNotAnnotated(e)
}

type baseTestServiceServer struct {
	UnsafeTestServiceServer
	base fixtures.TestServiceServer
}

func RegisterTestServiceBaseServer(s grpc.ServiceRegistrar, base fixtures.TestServiceServer) {
	RegisterTestServiceServer(s, baseTestServiceServer{base: base})
}

func (s baseTestServiceServer) EmptyMethodNotAnnotated(ctx context.Context, in *emptypb.Empty) (*emptypb.Empty, error) {
	return s.base.EmptyMethodNotAnnotated(ctx, in)
}
func (s baseTestServiceServer) EmptyMethodReleased(ctx context.Context, in *emptypb.Empty) (*emptypb.Empty, error) {
	return s.base.EmptyMethodReleased(ctx, in)
}
func (s baseTestServiceServer) MethodNotAnnotated(ctx context.Context, in *MessageNotAnnotated) (*MessageNotAnnotated, error) {
	baseIn := in.ToBase()
	baseOut, err := s.base.MethodNotAnnotated(ctx, baseIn)
	if err != nil {
		return nil, err
	}
	out := new(MessageNotAnnotated)
	out.FromBase(baseOut)
	return out, nil
}
func (s baseTestServiceServer) MethodReleased(ctx context.Context, in *MessageNotAnnotated) (*MessageNotAnnotated, error) {
	baseIn := in.ToBase()
	baseOut, err := s.base.MethodReleased(ctx, baseIn)
	if err != nil {
		return nil, err
	}
	out := new(MessageNotAnnotated)
	out.FromBase(baseOut)
	return out, nil
}
